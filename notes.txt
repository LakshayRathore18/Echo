ECHO  

Setup
Frontend
    - installed vite in frontend folder
Backend
    - npm init -y  
    - npm i express mongoose dotenv jsonwebtoken bcryptjs cookie-parser cloudinary socket.io   

    - create index.js and basic Setup
    - change script file in package.json to run on particular port 
        "scripts": {
            "dev": "nodemon index.js"
        },
    - add this line in package.json ( "type": "module" )for using import statement instead of require   
    - create src folder in backend and put index.js in it , also change script due to change of address : from index.js -> src/index.js
    - create these subfolders within src folder of backend : controllers, lib, middleware, models, routes. 

    - create auth.route.js  & auth.controller.js in routes & controllers resp.
    - create signup,login,logout route and logic in these files 
Database
    - create a new project on mongodbAtlas
    - create .env file in backend and paste the port & mongodb url
    - IMP: in mongodbUrl add ur db name before ?retrywrite line 
    - now in index.js add these lines
        import dotenv from "dotenv";
        dotenv.config() 
    - create db.js in lib for connecting db & export connectDB() function
    - go to mongodbAtlas->Network Acess-> allow ip from everywhere 
    - create user.model.js in models and make schema for user and export it 

Authorization
Signup
    - added code in signup thats take {name email password} from req.body
    - now go through if user miss any field then return json error for that 
    - if user filled everything perfectly then we salt & hash the password using bcrypt
    - now we create a user using schema 
    - then we create a jwt token for user which expires in 7 days (cookie), this generate token in lib/utils.js and then save the user.
    - downloaded POSTMAN app for posting request in signup in  json format & then get request in login that give us json token in cookie 
Login & Logout 
    Login
    - added code in login that takes {email, passowrd} from req.body
    - check if email exist and if password correct using bcrypt.compare
    - generate a jwt token for the user and return the user info in json 

    Logout 
    - clear the JWT token using this : res.cookie("jwt", "", { maxAge: 0 });  
Update Profile, CheckAuth & Cloudinary setup
    protectRoute middleware
    - firstly create a middleware named protectRoute in auth.middleware.js
    - this will check if user is logged in or not 
    - middleware will take token from res.cookies.jwt and verify it with jwt_secret 
    - then it will take user by decoded token's userId, excluding the password field
    - in the end it will attach the user object to the request object for further use
    - next()
    -add cookie parser in app.js for parsing cookies 

    Cloudinary Setup
    - add cloudinary : cloud_name,api_key,apy_secret in .env file 
    - create cloudinary.js in lib folder and connect with cloudinary

    Update Profile
    - firstly create a route: router.put("/update-profile", protectRoute, updateProfile);
    - this will first call the function protectRoute to authorize user and then call updateProfile 
    - in updateProfile, first take the profilePic from body and upload profile picture to cloudinary 
    - then update user profile with new profile picture 

    CheckAuth
    - firstly create a route: router.get("/check", protectRoute, checkAuth);
    - this will first call the function protectRoute in which there is a line req.user = user so if user is verified then its stored in req 
    - in checkAuth, there is only one line : return res.status(200).json(req.user);
    - if there is a user in req.user it will return it.
    - it is used for checking like when we refresh

Message Routes 
    - create a message schema in model 
    - create message.route.js & message.controller.js in routes & controllers respectively
    - update index.js to use the message routes: app.use("/api/message", messageRoutes);
    
    in message.controller.js :

    GetUserForSidebar
    - this function will retrieve all users except logged-in user from the database excluding their passwords
    - return the users in the response

    SendMessage 
    - this function will take {senderId, receiverId, content} from req.body
    - it will create a new message document using the message schema
    - save the message to the database
    - return the saved message in the response

    GetMessage 
    - create getMessages function in message.controller.js
    - this function will take {senderId, receiverId} from req.query
    - it will retrieve all messages between the sender and receiver from the database
    - return the messages in the response

Signup & Login page(connecting frontend & backend too)
    - cd frontent and install : npm i react-router-dom react-hot-toast
    - install tailwindcss@3 
    - NOTE TIP for adding boilerplate in react write this:  rafce
Daisyui
    - npm i -D daisyui@latest & in tailwind.config.js do this, plugins: [daisyui]  
Router
    - in main.jsx do this 
        import { BrowserRouter } from 'react-router-dom'
        <StrictMode>
            <BrowserRouter>
                <App />
            </BrowserRouter>
        </StrictMode>,
    - in src folder create components and pages folder            
Axios
    - npm i axios   
    - create lib folder in src and within lib create axios.js
    - in axios.js, set up the axios instance with base URL and interceptors for handling requests and responses
Zustand
    - npm i zustand 
    - create store folder in src, within that  useAuthStore.js, set up the Zustand store for managing authentication state
    - in useAuthStore.js, define the authUser = null & initial state and actions for signingIn, LoggingIn, UpdatingProfile, isCheckingAuth and checking authentication status
    - create a checkAuth function that call the checkauth route in bakcend and if there is a user it set that to authuser if any error authuser is null and then in the end isCheckingAuth becomes false 

    - in app.jsx, we import : {authUser, checkAuth} = useAuthStore();
    - and in useEffect we call checkAuth function and console log authUser
CORS
    CORS (Cross-Origin Resource Sharing) allows your web application running on one domain to access resources from a different domain. When your frontend (http://localhost:5173) makes a request to the backend (http://localhost:8080), the CORS settings on your backend will check if the request is allowed based on the specified origin and headers. If it's allowed, the request will proceed; otherwise, it will be blocked.
    - in backend folder do this 
    - npm i cors & paste these lines
        import cors from 'cors';
            app.use(cors({
            origin: "http://localhost:5173",
            credentials: true,
        }));
lucide-react
    - npm i lucide-react
    - in app.jsx , if isCheckingAuth && !authuser then it will show loade {from lucide-react}
    - also if authuser? homepage,updateProfile,settingsPage : navigate to login page 
    - opposite for signup and login
Signup, Login Page & Navbar 
    - created a signup page in signup.jsx
    - also created a effect in right side which is is in AuthImagePattern.jsx in components folder 
    
    React Hot Toast  
    - it is for notification like sucess or failure 
    - import & add <Toaster/> in the end of the App.jsx
    - using this in validateform & signup login and logout function in useAuthStore

    - after this created login page just like signup and give data to useauth zustand which acts as a mediator b/w frontend and backend 
    - also created navbar 

ProfilePage
    - created a profile page where user can see his info and also update profile pic 
    - then just update the info by sending data to backend 

SettingPage & daisyui
    - using for multiple theme options 
    - in tailwind.config.js add these
        plugins: [daisyui],
        daisyui: {
            themes: ["light", "dark","cupcake","synthwave"]..... //add all the themes check the file tbh ,
        },
    - create a folder constants in src, within constants create a file index.js and export theme from there onwards
    - create a file useThemeStore in store and wrote function for giving theme
    - imported that theme in app.jsx and set it in first div 
    - now create settings page with different theme and when clicked on any it called setTheme and set that theme there is also a preview section created 

HomePage
    - divided into three main components:
        - HomePage.jsx: main container
        - Sidebar: shows conversations
        - ChatContainer: shows messages
        - NoChatSelected: shown when no chat is selected

    HomePage.jsx
    - uses flex layout with max width of 6xl
    - shows either ChatContainer or NoChatSelected based on selectedUser
    - centered layout with padding and rounded corners
    
    Sidebar
    - fixed width: 20px on mobile, 72px on desktop
    - shows contacts header with Users icon
    - toggle for showing online-only users (desktop only)
    - displays user list with:
        - profile picture
        - online status indicator (green dot)
        - name and online status (desktop only)
    - highlights selected conversation
    - uses SidebarSkeleton during loading

    ChatContainer
    - three main sections:
        - ChatHeader: shows selected user info
        - Messages area: scrollable message history
        - MessageInput: for sending messages
    - messages aligned left (chat-start) for received, right (chat-end) for sent
    - each message shows:
        - sender's profile picture
        - timestamp
        - message content (text and/or image)
    - uses MessageSkeleton during loading

    MessageInput
    - features:
        - text input field
        - emoji picker with click-outside detection
        - image upload with preview and size limit (5MB)
        - send button with loading state
    - handles both text and image messages
    - shows loading spinner while sending

    State Management (useChatStore)
    - manages:
        - messages array
        - users list
        - selected user
        - loading states
    - functions:
        - getUsers: fetches user list
        - getMessages: fetches chat history
        - sendMessage: sends new message
        - setSelectedUser: updates selected chat



Socket.io Integration
Backend Setup
    1. Install socket.io in backend
        - npm i socket.io

    2. Create socket.js in backend/src/lib
        - Create basic Express and HTTP server setup
        - Initialize Socket.io with CORS configuration
        - Create userSocketMap object to track online users {userId: socketId}
        - Export app, server, and io instance
        - Create getReceiverSocketId helper function
        - Set up connection event handler:
            * Store userId-socketId mapping when user connects
            * Broadcast online users list
            * Handle disconnect event and update online users

    3. Update backend/src/index.js
        - Remove express app creation (now imported from socket.js)
        - Import { app, server } from socket.js
        - Replace app.listen with server.listen

    4. Update message.controller.js
        - Import io and getReceiverSocketId from socket.js
        - In sendMessage function:
            * Get receiver's socket ID
            * Emit 'newMessage' event to receiver if online

Frontend Setup
    1. Install socket.io-client
        - npm i socket.io-client

    2. Update useAuthStore.js (Authentication State)
        - Add socket and onlineUsers to state
        - Create connectSocket function:
            * Initialize socket with user ID
            * Connect to backend
            * Listen for 'getOnlineUsers' event
            * Update onlineUsers state
        - Create disconnectSocket function
        - Call connectSocket after successful:
            * Login
            * Signup
            * CheckAuth
        - Call disconnectSocket on logout

    3. Update useChatStore.js (Chat State)
        - Add socket message subscription:
            * Create subscribeToMessages function:
                - Listen for 'newMessage' event
                - Add new messages to state
            * Create unsubscribeFromMessages function:
                - Remove 'newMessage' event listener
        - Call subscribe/unsubscribe in ChatContainer useEffect

    4. Update ChatContainer.jsx
        - Add socket subscription in useEffect:
            * Subscribe to messages when component mounts
            * Unsubscribe when component unmounts
        - Handle real-time message updates

Key Concepts:
    - Socket.io enables real-time, bidirectional communication
    - userSocketMap tracks which users are online
    - Events used:
        * 'connection': When user connects
        * 'disconnect': When user disconnects
        * 'getOnlineUsers': Broadcast online users list
        * 'newMessage': Send new messages to receivers

Socket.io Terms & Concepts Explained
    1. Basic Terms
        socket.io: 
            - A library that enables real-time, bidirectional communication between web clients and servers
            - Like a telephone line that stays open between browser and server

        socket: 
            - An individual connection between client and server
            - Think of it as one end of the communication channel

    2. Connection Methods
        io.connect(): 
            - Creates connection from client to server
            - Example: const socket = io("http://localhost:8080")

        socket.disconnect():
            - Closes the connection
            - Used when logging out or cleaning up

    3. Event Handling
        emit(): 
            - Sends an event/message
            - Different ways to emit:
                * socket.emit(): Sends to specific socket
                * io.emit(): Sends to all connected sockets
                * io.to(socketId).emit(): Sends to specific socket by ID
            - Example: socket.emit("newMessage", messageData)

        on(): 
            - Listens for events
            - Like an event listener in regular JavaScript
            - Example: socket.on("newMessage", (message) => {})

        off(): 
            - Removes event listener
            - Important for cleanup to prevent memory leaks
            - Example: socket.off("newMessage")

    4. Room Concepts
        socket.join(room): 
            - Adds socket to a room
            - Rooms group multiple sockets together

        io.to(room).emit(): 
            - Sends message to all sockets in a room
            - Useful for group chats

    5. Server-Side Special Events
        connection: 
            - Fired when client connects
            - Example: io.on("connection", (socket) => {})

        disconnect: 
            - Fired when client disconnects
            - Example: socket.on("disconnect", () => {})

    6. Namespace Concepts
        io.of("/namespace"):
            - Creates separate communication channels
            - Like different channels on a radio

    7. Error Handling
        connect_error: 
            - Fired when connection fails
            - Example: socket.on("connect_error", (error) => {})

        connect_timeout: 
            - Fired when connection times out
            - Example: socket.on("connect_timeout", (timeout) => {})

    8. Connection States
        socket.connected: 
            - Boolean indicating if socket is connected
            - Example: if(socket.connected) { ... }

        socket.disconnected: 
            - Boolean indicating if socket is disconnected
            - Example: if(socket.disconnected) { ... }

    9. Middleware Concepts
        io.use(): 
            - Adds middleware to socket.io
            - Used for authentication, logging, etc.
            - Example: io.use((socket, next) => { ... })

    10. Best Practices
        - Always clean up listeners using off()
        - Handle reconnection scenarios
        - Implement error handling
        - Use rooms for efficient broadcasting
        - Implement authentication/authorization

Socket.io Flow in Codebase (Simple Explanation)

    1. Initial Setup & Connection
        Backend (socket.js):
            - Creates a socket server that listens for connections
            - Maintains a userSocketMap to track who's online
            - Example: userSocketMap = { "userId123": "socketABC" }

        Frontend (useAuthStore.js):
            - When user logs in/signs up/refreshes page
            - Creates socket connection with their userId
            - Like saying "Hey server, I'm user123 and I'm online!"

    2. Online Users Tracking
        When User Connects:
            - Backend adds them to userSocketMap
            - Broadcasts updated online users list to everyone
            - Like announcing "Hey everyone, user123 just came online!"

        When User Disconnects:
            - Backend removes them from userSocketMap
            - Broadcasts updated list
            - Like announcing "user123 just went offline!"

    3. Message Flow
        Sending a Message:
            1. User clicks send in ChatContainer
            2. Frontend:
                - Saves message through API
                - Shows message immediately in chat
            3. Backend:
                - Saves message to database
                - Checks if receiver is online (using userSocketMap)
                - If online, sends message directly to their socket
                - Like tapping someone's shoulder to say "hey, new message!"

        Receiving a Message:
            1. Backend emits 'newMessage' to receiver's socket
            2. Frontend (useChatStore.js):
                - Listens for 'newMessage' events
                - When received, adds message to chat
                - Like your phone getting a notification and updating chat

    4. Real-time Updates
        ChatContainer:
            - Subscribes to messages when opened
            - Unsubscribes when closed
            - Like turning on/off your phone's notifications

        Online Status:
            - Shows green dot for online users
            - Updates in real-time as users connect/disconnect
            - Like WhatsApp's online status

    5. Cleanup
        - When user logs out:
            * Disconnects socket
            * Clears user from online list
            * Like hanging up a phone call

    Think of it like a phone system:
    - Socket.io server is the telephone exchange
    - Each user has a phone line (socket connection)
    - userSocketMap is like a phone directory
    - Messages are like phone calls
    - Online status is like seeing if someone's phone is on

Deployment(imp) 
    - firstly we are transfering entire frontend that was on localhost:5173 to backend that is localhost:8080
    - in the root folder : npm init -y
    - in package.json we add build and start scripts (delete node_modules folder from backend and frontend and run : npm run build in root folder)
    - in backend package.json we add start and dev scripts
    - created .gitignore file in root, cut and paste the content of .gitignore file from  frontend folder and paste it in root .gitignore file
    - in index.js we added production configuration to serve the frontend build files
    - in axios.js and useAuthStore.js we added production configuration to use the backend url
    - in root folder :
        - git init






